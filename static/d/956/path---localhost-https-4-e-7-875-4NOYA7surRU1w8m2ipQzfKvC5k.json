{"data":{"site":{"siteMetadata":{"title":"Blog","author":"Atul R"}},"markdownRemark":{"id":"5f9c65d7-94db-5286-b0a3-ee13f0fbcc69","excerpt":"Recently, Google security blog published an article  here  which states: Beginning in July 2018 with the release of Chrome 68, Chrome will…","html":"<p>Recently, Google security blog published an article <a href=\"https://security.googleblog.com/2018/02/a-secure-web-is-here-to-stay.html\">here</a> which states:</p>\n<blockquote>\n<p>Beginning in July 2018 with the release of Chrome 68, Chrome will mark all HTTP sites as “not secure”.</p>\n</blockquote>\n<p>Google has been pushing for HTTPS for sometime now. A blog post in 2014 <a href=\"https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html\">here</a> tells us that Google’s search engine ranks HTTPS websites over unsecure HTTP websites.</p>\n<p>While more and more websites and apps are becoming HTTPS enabled, we still develop these web apps on our local development environment over HTTP.\nSince web browsers behave slighlty differently when serving HTTPS and HTTP website, this can lead to few issues when we deploy to production.</p>\n<p>One such issue is mixed content because some of the resource might be loaded using HTTP on a HTTPS site.  <a href=\"https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content\">More on mixed content here</a>\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/active-mixed-content-errors-c8517488bc3abb7f78a5f5108757ac11-346f0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; ; max-width: 586px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 75.25597269624573%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAACyklEQVQozyVSaW+jOADl//+f0WpnJ206ScDgA8xhMMQYCBCuJE3TNkC6ZT1a6enpyR/sd1ibg6A1zcYyS2BUlnnU9ca2m/2+iWOFI+ddkiiRe15iWYlhCAA6xrogeMsLbWyOB4yL3U4aRmpZuQK0Cl3nCIUYO7pODYMCwG2787zGNK+u+10Ui0Lfa1Oa1gidKZ1ZMDn2bJozdb6UZmzy/Ttj9zAcGXtzaGfbrU0Un9U552NZahPnpQlK08oNvQCg3G1LhMqQlYFf+v7B82rGlBAYSwAyXc8N45Wxi+/fskwbj8cK49LQS9MsICwhrDCqfv+udjvhOAxCDwCFxLaHIDgh1EE0S7mUh+V81r7jeMRo0vUHISOED4xnBB9JPHP+iMI55lMUzXF8dZwawSOEDeetlJfD4aOutWm/Ly3rAIBQTwEgdT1DKPM86bpSNew4igWlnJAMwsIwVMaPJPmIos9CtV3Xymq53dbAqAFQs7WW1W63FYQpIdw0Q8MIgZHapHfdBqGe4M8kuYv9v12nzXl+MsFViKkslyxbYv7NoyWTixB/sN8vebGk4kvs7zG/CzHG/BYE71U19Z2mSj8jdCGkV7d67oDgiTonmQ1FMeR5J+Upz4c0zXw/wVggJAkZkmSIotdMamquzLLkZiMUVGBgyO0mW6/l05MaJl2vs+1OuvTA2Dvn75736bpLni+qcGX7UR1f1QwYdQiptBeHDv+7sMzOJs12M/h+K8S9KFS1d9V8Kv58r6pa3t60sbP7cHcS1rC3zgnoY/2akanl45FNfTK20XRJp1tx7eImc9vUaSQdDn6Xu+8nod0uLPCeKfmbwL9s8pOSfzy68uiT46yp84zgL4xXBP2y8RNzVzb8kYTrS+9eejp+CO39NQndNQ9eZLwR4Ytgz4KtFSfhJg5emLMKnBWjq8h7PmQkF1ZbufebWL7q77n6D53dADQxLy9IAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"mixed-content\"\n        title=\"\"\n        src=\"/static/active-mixed-content-errors-c8517488bc3abb7f78a5f5108757ac11-346f0.png\"\n        srcset=\"/static/active-mixed-content-errors-c8517488bc3abb7f78a5f5108757ac11-2834f.png 148w,\n/static/active-mixed-content-errors-c8517488bc3abb7f78a5f5108757ac11-39b60.png 295w,\n/static/active-mixed-content-errors-c8517488bc3abb7f78a5f5108757ac11-346f0.png 586w\"\n        sizes=\"(max-width: 586px) 100vw, 586px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Issues like these can be prevented by using HTTPS on development machine (localhost).\nAlso, enabling HTTPS on the development version would allow it to be much more closer to the production version of the web app and hence would allow you to catch those bugs which would only show up after you deploy. </p>\n<h2>Overview of SSL Certificate generation process</h2>\n<h2>Setup local HTTPS development environemt</h2>\n<p><em>PS: Although this guide is for linux and Mac OS, Windows users can run equivalent commands and achieve the same result.</em>   </p>\n<p>FIRST STEP: CREATE A SELF SIGNED CA that will issue our certificates.</p>\n<p>1.\nWhether you are getting a certificate from a CA or generating your own self-signed certificate, the first step is to generate a key.\nopenssl genrsa -des3 -out rootca.secure.key 2048 - generate a key with pass (password:password)</p>\n<ol start=\"2\">\n<li>Now lets generate a insecure key\nopenssl rsa -in rootca.secure.key -out rootca.insecure.key</li>\n</ol>\n<p>We will use rootca.insecure.key to generate certificates. But you can also use rootca.secure.key instead and enter the passwords when prompted.\nIssue with using unsecure key is that if you accidentally expose the key all your certifiactes and services will also be vulnerable.\nBut since we are using it for development purpose at this time. Lets go ahead and use unsecure keys.</p>\n<ol start=\"3\">\n<li>Now lets generate the root SSL certificate using our ca key.\nopenssl req -new -x509 -nodes -key rootca.insecure.key -sha256 -out cacert.pem -days 3650\nEnter data that is asked. You can fill dummy values also for now</li>\n</ol>\n<p>SECOND STEP: CREATE A CERTIFICATE SIGNING REQUEST</p>\n<ol start=\"4\">\n<li>\n<p>Now lets generate a new key for csr and domain certificate issuing\nopenssl genrsa -des3 -out localdomain.secure.key 2048 - generate a key with pass (password:password)\nopenssl rsa -in localdomain.secure.key -out localdomain.insecure.key</p>\n</li>\n<li>\n<p>Now we will generate a certificate sign request\ncreate a configuration file for our local domain (localdomain.csr.cnf):\n[req]\ndefault<em>bits = 2048\nprompt = no\ndefault</em>md = sha256\ndistinguished_name = dn</p>\n</li>\n</ol>\n<p>[dn]\nC=IN\nST=SomeState\nL=SomeCity\nO=SomeOrganization\nOU=SomeUnit\nemailAddress=test@test.com\nCN = localhost</p>\n<p>openssl req -new -sha256 -nodes -out localdomain.csr -key localdomain.insecure.key -config localdomain.csr.cnf</p>\n<p>LAST STEP: CREATE THE DOMAIN CERTIFICATE</p>\n<ol start=\"5\">\n<li>Now use the localdomain.csr (certificate signing request) and our CA certificate to generate the localdomain certificate.\nWe need another configuration file for local domain:\nlets name it localdomain.v3.ext</li>\n</ol>\n<p>authorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nsubjectAltName = @alt_names</p>\n<p>[alt_names]\nDNS.1 = localhost</p>\n<p>Now run the command\nopenssl x509 -req -in localdomain.csr -CA cacert.pem -CAkey rootca.insecure.key -CAcreateserial -out localdomain.crt -days 500 -sha256 -extfile localdomain.v3.ext</p>\n<p>This will generate a domain certificate from our ca (localdomain.crt)</p>\n<p>Important files now to keep for next step are:\n-your ca/root ssl certificate: cacert.pem\n-your domain certificate: localdomain.crt\n-your domain key: localdomain.insecure.key</p>\n<h2>IMPORTING TO BROWSERS</h2>\n<p>We need both localdomain.insecure.key and localdomain.crt to import the crt to browsers.\nHence, We will combine them to generate a pfx file. Which is basically a container containing both certificate and the key.\nThis will help us import it into browsers smoothly.\nSo to do that\nopenssl pkcs12 -export -out localdomain.pfx -inkey localdomain.insecure.key -in localdomain.crt</p>\n<p>// IMPORT TO CHROME</p>\n<p>ONE: Type in url bar of chrome and press enter.\nchrome://settings/certificates</p>\n<p>TWO: Now go to the tab “Authorities”\nWe will import our CA (cacert.pem) into this.\nClick on import\nCheck the Trust this certificate for identifying websites checkbox and press OK.\n(If you scroll through the CA list you should see our CA at org-Testing or whatever you entered while generating it)</p>\n<p>THREE: Import the domain certificates\nNow go to “Your Certifiactes Tab”\nClick on import\nAnd choose localdomain.pfx file.\nIf it asks for password enter the export password you used while creating the pfx</p>\n<p>//IMPORT TO FIREFOX\n6.</p>\n<p>ONE: Type in url bar of firefox and press enter.\nabout:preferences#privacy\nNow scroll down to Certifiactes(under security)\nand click on “View Certifiactes”</p>\n<p>TWO: Now go to the tab “Authorities”\nWe will import our CA (cacert.pem) into this.\nClick on import\nCheck the “Trust this CA  to identifying websites” checkbox and press OK.\n(If you scroll through the CA list you should see our CA at org-Testing or whatever you entered while generating it)</p>\n<p>THREE: Import the domain certificates\nNow go to “Your Certifiactes Tab”\nClick on import\nAnd choose localdomain.pfx file.\nIf it asks for password enter the export password you used while creating the pfx</p>\n<p>// RUNNING A DEV SERVER (http-server npm module)\n// -----------------------------------------\nmkdir project\ncd project\nnpm install -g http-server\necho “Hello World” > index.html\nhttp-server -a localhost —ssl —cert <path to>/localdomain.crt —key <path to>/localdomain.insecure.key</p>\n<p>This runs the site in ssl mode in dev server.</p>\n<p>Now open up <a href=\"https://localhost:8080\">https://localhost:8080</a> and you should see it showing https in green with secure tag on it.</p>\n<p>// Using the certificates in a NodeJS backend locally\n//----------------------------------------------------\nindex.js\n==========\nconst https = require(“https”);\nconst fs = require(‘fs’);\nconst path = require(‘path’);</p>\n<p>const port = 3000;</p>\n<p>const certOptions = {\nkey: fs.readFileSync(path.resolve(‘../localdomain.insecure.key’)),\ncert: fs.readFileSync(path.resolve(‘../localdomain.crt’))\n};</p>\n<p>https.createServer(certOptions, (reqst, resp) => {\nresp.writeHead(200, {‘Content-Type’: ‘text/plain’});\nresp.end(‘Hello World Node!’);\n}).listen(port); </p>\n<p>console.log(‘Load <a href=\"https://localhost:\">https://localhost:</a>’ + port);</p>\n<p>After this run node index.js and server should be running at\n<a href=\"https://localhost:3000\">https://localhost:3000</a></p>\n<p>Open up <a href=\"https://localhost:3000\">https://localhost:3000</a> and you should https working on local</p>\n<p>Keep in mind use these certificates only for development.\nThese wont work in production as the certificate authority will not be trusted in your users browsers.\nFor production. generate a csr and then send it you CA and CA will generate a domain certificate for you.</p>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://security.googleblog.com/2018/02/a-secure-web-is-here-to-stay.html\">https://security.googleblog.com/2018/02/a-secure-web-is-here-to-stay.html</a></li>\n<li><a href=\"https://support.google.com/webmasters/answer/6073543?hl=en\">https://support.google.com/webmasters/answer/6073543?hl=en</a></li>\n<li><a href=\"https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html\">https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html</a></li>\n<li><a href=\"https://www.theregister.co.uk/2018/02/08/google_chrome_http_shame/\">https://www.theregister.co.uk/2018/02/08/google<em>chrome</em>http_shame/</a></li>\n<li><a href=\"https://help.ubuntu.com/lts/serverguide/certificates-and-security.html.en-GB\">https://help.ubuntu.com/lts/serverguide/certificates-and-security.html.en-GB</a></li>\n<li><a href=\"https://medium.freecodecamp.org/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec\">https://medium.freecodecamp.org/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec</a></li>\n</ul>","frontmatter":{"title":"🔐 HTTPS certificate generation explained! Now setup HTTPS for local development environment (without sudo)","date":"August 04, 2018"},"fields":{"slug":"/localhost-https/"}}},"pageContext":{"slug":"/localhost-https/","previous":null,"next":null}}